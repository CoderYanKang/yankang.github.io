<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redux自定义中间件]]></title>
    <url>%2F2018%2F06%2F13%2Fredux%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[由于业务逻辑的多样性，可能开源的一些第三方的中间件无法满足我们的需求，我就需要根据自己的业务逻辑，去自定义适合我们业务处理的中间件。 ###定义中间件 12345678let MyMiddleware = store =&gt; next =&gt; action =&gt;&#123; console.log(&apos;执行到我的中间件&apos;); if (action.type === &apos;my&apos;) &#123; return next(action); &#125;&#125;;export default MyMiddleware; store =&gt;next =&gt; action =&gt; 其实就是一层一层的向外返回action; ###添加到store中 123import &#123;createStore , applyMiddleware&#125; from &apos;redux&apos;;import MyMiddleware from &apos;./MyMiddleware&apos;;let store = createStore(counter , applyMiddleware(MyMiddleware));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React-Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux的使用]]></title>
    <url>%2F2018%2F06%2F10%2Freact-redux%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在实际的开发过程中，由于一个App通常比较复杂。我们不能在每个需要使用Store的地方，都通过import文件导入。一方面，加大维护难度，另一方面，可能我们根本不知道Store文件的绝对位置。 对于这种情况，我们应该在最顶层的父组件通过props依次传递下去。作为Store引入的唯一入口，但这样的缺陷时，所有的子组件都需要传递，即使你根本没有使用它，你也需要将它传递下去，对于开发者这是很不友好的。 React的Context可以帮助我们完美解决这个问题所谓Context，就是上下文环境，和Android的Context很像，可以让整个组件树都可以访问的一个公共对象。 首先，父组件需要配置Context，提供Context支持，其次，子组件说明自己需要Context，可以通过this.context访问这个公共的环境对象。 传递例图 ###使用Context传递store首先，创建一个叫Provider的父组件，用户提供store传递的容器组件。 123456789101112131415161718import PropTypes from &apos;prop-types&apos;;import React,&#123;Component&#125; from &apos;react&apos;;export default class Provider extends Component&#123; //支持Context getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; //只渲染子组件 render() &#123; return this.props.children; &#125;&#125;//让Provicer 能够被React认可为一个Context提供者Provider.childContextTypes = &#123; store: PropTypes.object&#125;; index.js 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;import &#123;counter , addGun , removeGun &#125; from &apos;./index.redux&apos;;import &#123;createStore , applyMiddleware&#125; from &apos;redux&apos;;import MyMiddleware from &apos;./MyMiddleware&apos;;import Provider from &apos;./Provider&apos;;// let store = createStore(counter , applyMiddleware(MyMiddleware));let store = createStore(counter);const render = () =&gt; ReactDOM.render( &lt;Provider store = &#123;store&#125;&gt; &lt;App addGun = &#123;addGun&#125; removeGun = &#123;removeGun&#125;/&gt; &lt;/Provider&gt; , document.getElementById(&apos;root&apos;));registerServiceWorker();render();//注册监听store.subscribe(render); app.js 1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import &apos;./App.css&apos;;class App extends Component&#123; render() &#123; //使用this.context访问上下文对象 const store = this.context.store; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;现在拥有我们拥有重机枪 &#123;store.getState()&#125; 把&lt;/p&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(this.props.addGun())&#125;&gt;捡到重机枪&lt;/button&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(this.props.removeGun())&#125;&gt;丢掉重机枪&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;//使用Context需要知道Context类型App.contextTypes = &#123; store: PropTypes.object&#125;;export default App; 如果我们自定义constructor方法，需要将contxt传入参数，不然无法正常使用context 1234constructor(props , context)&#123; super(props , context); ...&#125; 因为Context，我们不需要反复传递store ，只需要在store入口添加context支持方法及context类型。在需要使用的地方知道context类型，使用thi.context调用即可。 不过官方提示我们不要滥用Context，除非你真的需要 ###react-redux的出现 react-redux，将这块逻辑抽离出来了，有了react-redux我们可以直接在容器组件中传递store即可。 ###react-redux的构成 Provider组件为容器组件提供store对象，来生成UI组件参数。不用一层一层去传递store。 connect()react-redux提供connect方法，用于生成容器组件。 容器组件，负责数据逻辑和处理 ，不负责UI的渲染，又叫聪明组件。傻瓜组件，只负责UI的渲染，将容器组件提供的数据渲染出来。 app.js 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import &#123; connect &#125;from &apos;react-redux&apos;;import &#123;addGun , removeGun &#125; from &apos;./index.redux&apos;;class App extends Component&#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;现在拥有我们拥有重机枪 &#123;this.props.num&#125; 把&lt;/p&gt; &lt;button onClick=&#123;this.props.addGun&#125;&gt;捡到重机枪&lt;/button&gt; &lt;button onClick=&#123;this.props.removeGun&#125;&gt;丢掉重机枪&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;//传递的state数据function mapStateToProps(state)&#123; return &#123;num: state&#125;;&#125;//返回 ActionCreaterconst actionsCreater = &#123;addGun , removeGun&#125;;//包裹容器组件export default connect(mapStateToProps , actionsCreater)(App); index.js 12345678910111213141516171819202122import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;import &#123;counter&#125; from &apos;./index.redux&apos;;import &#123;createStore , applyMiddleware&#125; from &apos;redux&apos;;import MyMiddleware from &apos;./MyMiddleware&apos;;// import Provider from &apos;./Provider&apos;;// let store = createStore(counter , applyMiddleware(MyMiddleware));import &#123;Provider&#125; from &apos;react-redux&apos;;// import Provider from &quot;./Provider&quot;;let store = createStore(counter);const render = () =&gt; ReactDOM.render( &lt;Provider store = &#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; , document.getElementById(&apos;root&apos;));registerServiceWorker();render();//注册监听store.subscribe(render); index.redux.js 123456789101112131415161718192021222324//action 类型const ADD_GUN = &apos;add_gun&apos;;const REMOVE_GUN = &apos;remove_gun&apos;;export function counter(state = 0 , action)&#123; if(action) switch (action.type) &#123; case ADD_GUN: return state + 1; case REMOVE_GUN: return state - 1 &gt;= 0 ? state - 1 : 0; default: return 10; &#125;&#125;export function addGun()&#123; return &#123;type : ADD_GUN&#125;;&#125;export function removeGun()&#123; return &#123;type : REMOVE_GUN&#125;;&#125; 使用装饰品配置connect安装装饰器库 1npm install babel-plugin-transform-decorators-legacy –save-dev 安装babel-plugin-import 1npm install babel-plugin-import –save-dev 安装react-app-rewired 1npm react-app-rewired –save-dev 在项目根目录下配置 config-overrides.js 123456const &#123; injectBabelPlugin &#125; = require(&apos;react-app-rewired&apos;);module.exports = function override(config, env)&#123; config = injectBabelPlugin([&quot;transform-decorators-legacy&quot;], config); return config;&#125;; package.json 12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;boss_app&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;react&quot;: &quot;^16.4.0&quot;, &quot;react-dom&quot;: &quot;^16.4.0&quot;, &quot;react-redux&quot;: &quot;^5.0.7&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot;, &quot;redux&quot;: &quot;^4.0.0&quot;, &quot;redux-thunk&quot;: &quot;^2.3.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-plugin-import&quot;: &quot;^1.2.0&quot;, &quot;react-app-rewired&quot;: &quot;^1.2.9&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot; &#125;&#125; 也可eject后再配置，这里没有通过eject实现。 另一种使用 app.js 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;import &#123; connect &#125;from &apos;react-redux&apos;;import &#123;addGun , removeGun &#125; from &apos;./index.redux&apos;;//传递的state数据function mapStateToProps(state)&#123; return &#123;num: state&#125;;&#125;//返回 ActionCreaterconst actionCreater = &#123;addGun , removeGun&#125;;//包裹容器组件@connect(mapStateToProps , actionCreater)class App extends Component&#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;现在拥有我们拥有重机枪 &#123;this.props.num&#125; 把&lt;/p&gt; &lt;button onClick=&#123;this.props.addGun&#125;&gt;捡到重机枪&lt;/button&gt; &lt;button onClick=&#123;this.props.removeGun&#125;&gt;丢掉重机枪&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React-Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux中间件]]></title>
    <url>%2F2018%2F06%2F05%2Fredux%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[初次接触到中间件是在Connect和Express中，给我的直观印象是很像okhttp的拦截器。 Redux中间件是什么Redux中间件依赖applyMiddleware函数，通过对store.dispatch方法进行改造，在发出action行为和执行Reducer执行之间，来添加一些扩展的功能，比如增加日志打印，异步处理，错误捕获等功能。 模拟添加日志打印中间件 12345678let next = store.dispatch;//改造dispatch方法store.dispatch = function dispatchAndLog(action) &#123; //前后添加日志 console.log(&apos;dispatching&apos;, action); next(action);//执行dispatch console.log(&apos;next state&apos;, store.getState());&#125; ####中间件的使用 以redux-thunk中间件为例，redux-thunk是一个处理异步任务（耗时操作）的中间件，常用于store.dispatch一些耗时操作或网络请求的场景。Action Creator默认是返回对象的，redux-thunk返回的函数。 在构造store时添加中间件支持多个中间件可能和顺序有关 12345678import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import counter from &apos;./index.redux&apos;; const store = createStore( counter, applyMiddleware(thunk)); 模拟耗时操作，发送异步Action 123setTimeout(() =&gt; &#123; this.props.dispatch(&#123; type: &apos;WAIT_5_SECOND&apos; &#125;)&#125;, 5000) 实际应用场景 12345678910111213141516171819202122function getUserDetail (userId) &#123; return (dispatch, getState) =&gt; &#123; if (getState().user.id === userId) &#123; // store中的user和目标user一致，无需重复获取 return; &#125; //开始请求 dispatch(&#123;type: &apos;USER_DETAIL_REQUEST&apos;, payload: userId&#125;); fetch(`$&#123;API_ROOT&#125;/user/$&#123;userId&#125;`) .then(res =&gt; res.json()) .then(res =&gt; &#123; // 请求成功，发送成功Action dispatch(&#123;type: &apos;USER_DETAIL_REQUEST_SUCCESS&apos;, payload: res&#125;); &#125;) //请求失败，发送失败Action .catch(err =&gt; dispatch(&#123;type: &apos;USER_DETAIL_REQUST_FAILURE&apos;, payload: err&#125;) &#125;;&#125;// 获取用户详情store.dispatch(getUserDetail(100)); ####常用的Redux中间件redux-logger redux-promise （Action Creator可以promise的异步处理中间件） redux-saga（异步处理）]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Redux]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%88%9D%E8%AF%86redux%2F</url>
    <content type="text"><![CDATA[说实话，懒了很久，虽然自己工作之余，也在零零碎碎的学习React相关的知识，不断的提高自己React Native ， React技术栈的能力，却也没有好好的总结反思。加上自己从事的是移动开发（Android 开发）。越是觉得有必要好好总结，巩固一下 懒还话多！！！ ###为什么需要Redux多于大多数React应用，使用props , state足够处理简单的react app中组件直接的数据传递，配和context，我们可以解决大部分问题。 但是，当你的项目的业务逻辑复杂到一定的程度，组件太多，需要管理更多不断变化的state，前面的方法就会显得很痛苦。Redux的出现就是为了解决复杂应用中状态管理混乱的问题。 不过，对于简单的APP使用Redux是在无意义的增加开发复杂度。 ###Redux重要组成部分 1、用户发出 Action操作 1store.dispatch(action); 2、Store自动调用 Reducer方法。reducer方法（参数 state ，参数 action） 1234count(state , action)&#123; //根据不同action 返回不同的state return state;&#125; 3、State 发送改变后 ，Store 会触发监听函数 1store.subscribe(listener); 4、listener 根据store得到改变后getState() ，state。重新render组件 ###Action本质上是普通的javascript对象，它是将数据从组件传递到store的信使，很像Android中的intent。它必须有type字段数据来表示action的操作类型。 12345const GUN_ADD = &apos;add_gun&apos;;&#123; type: GUN_ADD, count: 10&#125; ###Reduceraction指定了我们的行为（修改更新指定的数据），确没有具体说明具体我们应该如何去修改更新数据。Reducers就是用来指定根据不同的action，来修改state数据逻辑的方法。 123456789101112131415const ADD_GUN = &apos;add_gun&apos;;const REMOVE_GUN = &apos;remove_gun&apos;;export function counter(state = 0 , action)&#123; if(action) switch (action.type) &#123; case ADD_GUN: return state + 1; case REMOVE_GUN: return state - 1 &gt;= 0 ? state - 1 : 0; default: return 10; &#125;&#125; ###Store将action和reducer联系起来。Redux应用只有一个单一的Store。可以有多个reducer. 维持应用的 state； 提供 getState() 方法获取 state，用于渲染组件； 提供 dispatch(action) 方法操作更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器 简单代码 app.js 12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;class App extends Component&#123; render() &#123; const store = this.props.store; return ( &lt;div className=&quot;App&quot;&gt;现在拥有我们拥有重机枪 &#123;store.getState()&#125; 把 &lt;button onClick=&#123;() =&gt; store.dispatch(this.props.addGun())&#125;&gt;捡到重机枪&lt;/button&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(this.props.removeGun())&#125;&gt;丢掉重机枪&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; index.redux.js 123456789101112131415161718192021222324//action 类型const ADD_GUN = &apos;add_gun&apos;;const REMOVE_GUN = &apos;remove_gun&apos;;export function counter(state = 0 , action)&#123; if(action) switch (action.type) &#123; case ADD_GUN: return state + 1; case REMOVE_GUN: return state - 1 &gt;= 0 ? state - 1 : 0; default: return 10; &#125;&#125;export function addGun()&#123; return &#123;type : ADD_GUN&#125;;&#125;export function removeGun()&#123; return &#123;type : REMOVE_GUN&#125;;&#125; index.js 123456789101112131415import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;import &#123;counter , addGun , removeGun &#125; from &apos;./index.redux&apos;;import &#123;createStore&#125; from &apos;redux&apos;;let store = createStore(counter);const render = () =&gt; ReactDOM.render( &lt;App store = &#123;store&#125; addGun = &#123;addGun&#125; removeGun = &#123;removeGun&#125;/&gt; , document.getElementById(&apos;root&apos;));registerServiceWorker();render();//注册监听store.subscribe(render); 总结简单的使用了一下Redux , 介绍了Redux的一些基本概念。后续 Redux 中间件connect、Context传递store、以及封装更好的React-Redux的使用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C文件操作]]></title>
    <url>%2F2017%2F02%2F07%2FC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C文件读写操作，是C语言在应用中一个很重要的知识点。特别是在多媒体（图片、音视频）处理中应用的非常多。 ##C文件操作 ###打开或创建新文件 FILE *fopen( const char * filename, const char * mode ); 参数： filename文件名 ， mode打开模式 ####普通文件 r 只读方式打开一个已有文件，文件必须存在 w 只写方式打开一个文件，不存在会创建，存在则清空 a 以追加的方式写文件，不存在会创建，存在会追加 r+ 以读写的方式打开，文件不存 不会创建 w+ 以读写的方式打开，文件不存在会创建 ， 存在会清空原内容 a+ 以追加方式读写文件, 文件不存在会创建新的文件, 文件存在会) 二进制文件 需要在mode 后面添加b“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b” ####读写文件字符读写函数: fgetc 和 fputc 只能处理文本文件，不能处理二进制文件 fgetc函数默认指向文件第一个位置。 12345678910const char* filename = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(filename, &quot;w+&quot;);while( ch != EOF) //EOF为文件结束&#123; ch = fgetc(fp); // putchar 把ch显示在屏幕上 putchar(ch); &#125; fclose(fp); fputc函数 向文件写入一个字符 12345678910const char* filename = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(filename, &quot;w+&quot;);ch = getchar();while( ch != EOF) //EOF为文件结束&#123; fputc(ch, fp); //fputc(ch, fp); 函数功能： 将字符（ch的值）输出到fp所指向的文件中去 ch = getchar();&#125;fclose(fp); ####fprintf 和 fscanf 函数 12int fscanf(FILE *, const char *, ...);int fprintf(FILE *, const char *, ...); FILE stream：文件指针char format：格式字符串[argument…]：输入列表 ####fprintf 函数 写入 123456789int i = 10;double fp = 1.5;char s[] = &quot;this is a string&quot;;char c = &apos;\n&apos;;stream = fopen(&quot;fprintf.out&quot;, &quot;w&quot;);fprintf(stream, &quot;%s%c&quot;, s, c);fprintf(stream, &quot;%d\n&quot;, i);fprintf(stream, &quot;%f\n&quot;, fp);fclose(stream); ####fscanf 函数 读取 1234567891011121314151617181920212223242526long l;float fp;char s[81];char c;stream = fopen(&quot;fscanf.out&quot;, &quot;w+&quot;);if(stream==NULL)printf(&quot;The file fscanf.out was not opened\n&quot;);else&#123; //写入数据 fprintf(stream,&quot;%s%ld%f%c&quot;,&quot;a-string&quot;, 65000,3.14159, &apos;x&apos;); //将指针设置至文件开头 fseek(stream,0L,SEEK_SET); //从文件中读取数据 fscanf(stream,&quot;%s&quot;,s); fscanf(stream,&quot;%ld&quot;,&amp;l); fscanf(stream,&quot;%f&quot;,&amp;fp); fscanf(stream,&quot;%c&quot;,&amp;c); //输出读取的数据 printf(&quot;%s\n&quot;,s); printf(&quot;%ld\n&quot;,l); printf(&quot;%f\n&quot;,fp); printf(&quot;%c\n&quot;,c); fclose(stream) &#125; fwrite与fread 二进制文件读写 size_t fwrite(const void , size_t, size_t, FILE );size_t fread(void , size_t, size_t, FILE ); ###返回值：返回实际写入的数据块数目 1、buffer：是一个指针，对fwrite来说，是要写入的数据的地址； 对于fread 是要接收读取数据的指针 2、size：要写入(读取)内容的单字节数； 3、count:要进行写入(读取)size字节的数据项的个数；size * count 写入的字节数 4、stream:目标文件指针； 5、返回实际写入的数据项个数count。 fwrite 字节写入 12345FILE * pFile;char buffer[] = &#123; &apos;x&apos; , &apos;y&apos; , &apos;z&apos; &#125;;pFile = fopen ( &quot;myfile.bin&quot; , &quot;wb&quot; );fwrite (buffer , sizeof(buffer), 1 , pFile );fclose (pFile); fread 字节读取 12345678910111213141516const char* file = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(file, &quot;rb&quot;); // 模式为读取if (fp == NULL)&#123; printf(&quot;failed to read file \n&quot;); return -1;&#125; char buf[2]; //读取文件while (!feof(fp))&#123; long len = fread(buf, 1, 2, fp); printf(&quot;读取的长度 %ld \n&quot; , len); printf(&quot;%s&quot; , buf);&#125; ####关闭文件 int fclose( FILE *fp ); 关闭文件成功返回0，失败返回EOF ####Fseek 指定位置读写 int fseek(FILE *stream, long offset, int fromwhere); 参数：offset 偏移量 frowwhere 偏移位置偏移起始位置：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// c 文件写入const char* filename = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(filename, &quot;wb&quot;);if (fp == NULL)&#123; printf(&quot;failed to open file\n&quot;); return -1;&#125;char buf[] = &quot;hello file&quot;;// 写入字符fwrite(buf, 1, sizeof(buf), fp); // 写入数字double num = 123.55;fwrite(&amp;num, 1, sizeof(num), fp); //写入字符串string text = &quot;\nwrite text&quot;;fwrite(&amp;text, 1,text.length(), fp); // 关闭文件fclose(fp); //读取文件const char* file = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(file, &quot;rb&quot;); // 模式为读取if (fp == NULL)&#123; printf(&quot;failed to read file \n&quot;); return -1;&#125; char buf[2];//从指定文件位置开始读取fseek(fp, 2, SEEK_SET);// fseek(fp, -2, SEEK_END); //读取文件while (!feof(fp))&#123; long len = fread(buf, 1, 2, fp); printf(&quot;读取的长度 %ld \n&quot; , len); printf(&quot;%s&quot; , buf);&#125; //按行写入char txt[20] = &quot;按行写入&quot;;double num = 123; const char* filename = &quot;CPP_01/aaa.txt&quot;;FILE* fp = fopen(filename, &quot;wb&quot;); fprintf(fp, &quot;%s\n&quot; , txt);fprintf(fp, &quot;%f\n&quot; , num);]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C结构体]]></title>
    <url>%2F2017%2F02%2F07%2FC%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[结构体 C中用户可自定义的数据类型，可以存放不同类型的值（数组用于存放相同的数据类型）。开发者可以根据实际情况创建一个新类型。 结构体可以包含结构体，在c++ 中结构体还可以包含函数，具有了类的部分功能。 ##定义 ###打开或创建新文件 1234struct 结构体标识&#123; 结构体成员列表 &#125;(结构体变量名) 三者至少出现2个 12345678910111213141516171819202122232425262728293031323334//结构体定义struct Cars&#123; //车名 char name[20]; //排量 float Tt; //马力 int power;&#125;; void useStruct()&#123; //定义结构体变量 struct Cars car1; struct Cars *car2; //结构体变量赋值 strcpy(car1.name , &quot;兰博基尼&quot;); car1.Tt = 2.0; car1.power = 300; LOGE(&quot;原车信息--车名：%s 排量： %1f 马力：%d&quot; , car1.name , car1.Tt , car1.power); LOGE(&quot;我换车了，哈哈&quot;); car2 = &amp;car1; strcpy(car2 -&gt; name , &quot;法拉利&quot;); car2 -&gt; Tt = 2.0; car2 -&gt; power = 500; LOGE(&quot;现车信息--车名：%s 排量： %f 马力：%d&quot; , car2 -&gt; name , car2 -&gt; Tt , car2 -&gt;power);&#125; E/native-dev(5376): 原车信息--车名：兰博基尼 排量： 2.000000 马力：300 E/native-dev(5376): 我换车了，哈哈 E/native-dev(5376): 现车信息--车名：法拉利 排量： 2.000000 马力：500 ####结构体中的结构体123456789101112131415161718192021222323456789101112//此结构体的声明包含了指向自己类型的指针（链表）struct HealthInfo&#123; char info[10];&#125;; struct Person&#123; char name[10]; struct HealthInfo *healthinfo;&#125;; 位域略]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C动态内存管理]]></title>
    <url>%2F2017%2F02%2F07%2FC%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[动态内存管理，即是在我们需要使用内存是进行动态分配所需要的存储空间，并在不需要时进行回收（内存泄露）的方法 ##C动态内存管理 背景C/C++ 定义的4个内存区间 1、代码区 2、全局变量与静态变量区 3、局部变量区（栈区） 4、动态存储区或自由存储区（堆区） 在实际开发中，当我们使用的变量的大小需要即时分配大小的时候。静态存储分配方式就显然无法满足需求。编译时我们无法预定存储空间的大小。 ###特点： 1、不需要预先分配存储空间。 2、分配的空间可以根据实际需求进行改变。 ###重要函数 1、内存分配函数 123extern __mallocfunc void* calloc(size_t, size_t);extern void *malloc(unsigned int num_bytes) 2、C修改分配的内存 1extern void* realloc(void *, size_t) 3、C释放分配的内存 1extern void free(void *) malloc 与 calloc的区别：calloc在动态分配完内存后，自动初始化该内存空间为0，而malloc不会初始化，存储的是随机数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int * dynamicintArray = (int*)malloc(sizeof(int) * 5);//判断是否分配了足够的内存if(dynamicintArray == NULL)&#123; LOGE(&quot;molloc error.....&quot;);&#125;else&#123; //初始值 for(int i = 0 ; i &lt; 5 ; i++) &#123; LOGE(&quot;初始值：%d&quot; , dynamicintArray[i]); &#125; for(int i = 0 ; i &lt; 5 ; i++) &#123; dynamicintArray[i] = i; &#125; for(int i = 0 ; i &lt; 5 ; i++) &#123; LOGE(&quot;value：%d&quot; , dynamicintArray[i]); &#125;&#125;//修改原有分配的内存大小 扩大或者缩小int* newdynamicintArray = (int*)realloc(dynamicintArray , sizeof(int) * 10);if(newdynamicintArray == NULL)&#123; LOGE(&quot;realloc error.....&quot;);&#125;else&#123; //改变分配空间 for(int i = 0 ; i &lt; 10 ; i++) &#123; LOGE(&quot;改变分配空间：%d&quot; , dynamicintArray[i]); &#125;&#125; //释放的内存free(dynamicintArray);E/native-dev(2196): 初始值：3E/native-dev(2196): 初始值：1E/native-dev(2196): 初始值：1600613985E/native-dev(2196): 初始值：829121646E/native-dev(2196): 初始值：1801735775E/native-dev(2196): value：0E/native-dev(2196): value：1E/native-dev(2196): value：2E/native-dev(2196): value：3E/native-dev(2196): value：4E/native-dev(2196): 改变分配空间：0E/native-dev(2196): 改变分配空间：1E/native-dev(2196): 改变分配空间：2E/native-dev(2196): 改变分配空间：3E/native-dev(2196): 改变分配空间：4E/native-dev(2196): 改变分配空间：1685419091E/native-dev(2196): 改变分配空间：1970536569E/native-dev(2196): 改变分配空间：6256996E/native-dev(2196): 改变分配空间：-292087456E/native-dev(2196): 改变分配空间：-375520288 使用 calloc 初始值为 0 12345678910E/native-dev(2196): 初始值：0E/native-dev(2196): 初始值：0E/native-dev(2196): 初始值：0E/native-dev(2196): 初始值：0E/native-dev(2196): 初始值：0E/native-dev(2196): value：0E/native-dev(2196): value：1E/native-dev(2196): value：2E/native-dev(2196): value：3E/native-dev(2196): value：4 ###memset函数 void memset(void s, int ch, size_t n); 将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。快速初始化 char buffer[4]; memset(buffer,0,sizeof(char)*4); strcpy(buffer,&quot;abc&quot;); //&quot;abc&quot;中最后隐藏的&apos;\0&apos;占一位，总长4位。 ###sizeof 函数 sizeof是何方神圣？？sizeof乃C/C++中的一个操作符（operator）是也，简单的说其作用就是返回一个对象或者类型所占的内存字节数。 语法： sizeof有三种语法形式，如下： 1) sizeof( object ); sizeof( 对象 ); 2) sizeof( type_name ); sizeof( 类型 ); 3) sizeof object; sizeof 对象; ###C各基本类型所占字节数 1234567891011121314151617181920212223242526272829303132333435363716位编译char ：1个字节char*(即指针变量): 2个字节short int : 2个字节int： 2个字节unsigned int : 2个字节float: 4个字节double: 8个字节long: 4个字节long long: 8个字节unsigned long: 4个字节 32位编译器 char ：1个字节char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理 64位编译器）short int : 2个字节int： 4个字节unsigned int : 4个字节float: 4个字节double: 8个字节long: 4个字节long long: 8个字节unsigned long: 4个字节 64位编译器 char ：1个字节char*(即指针变量): 8个字节short int : 2个字节int： 4个字节unsigned int : 4个字节float: 4个字节double: 8个字节long: 8个字节long long: 8个字节unsigned long: 8个字节]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android右对齐布局实践及优化]]></title>
    <url>%2F2017%2F02%2F07%2FAndroid%E5%8F%B3%E5%AF%B9%E9%BD%90%E5%AE%9E%E8%B7%B5%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[回想起去年做过的一个维语音乐平台，要求实现双语版本，汉语和维语。在维语版本中要求文字、控件，右对齐显示，我们都知道大部分语言都是左对齐，android默认的对齐方式也是左对齐方式。而像维语和阿拉伯语这种语言都是右对齐的，即是从右往左读的。 拿到这个问题我首先想到到的是自定义ViewGroup。233333~ 其实从Android 4.2 (api 17)开始 对rtl 提供了相应的支持。 项目中的实际效果 那我们来试一下吧~ 相关配置 minsdk 大于17 manifest 文件中添加 android:supportsRtl=”true” 使用 12345&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleX=&quot;-1&quot; //反向 android:src=&quot;@drawable/ic_record_voice_over_blue_900_36dp&quot; /&gt; 简单使用 ViewGroup 设置 android:layoutDirection=”rtl 或 trl”; TextView 内文字对齐方式 android:textAlignmen = “textEnd 或 textStart” 或 android:textDirection=”rtl 或 ltr” 特别的控件imageview 右对齐 viewpager 与 tablayout 右对齐，要求至右往左滑动 12345678910111213141516171819202122public class RTLViewPager extends ViewPager &#123; // direction private boolean mIsRtlOriented; public RTLViewPager(Context context)&#123; this(context, null); &#125; public RTLViewPager(Context context, AttributeSet attrs)&#123; super(context, attrs); &#125; //rtl 时设置当前页码 自定义属性修改更好 public void setRtlOriented(boolean isRtlOriented)&#123; mIsRtlOriented = isRtlOriented; if(mIsRtlOriented &amp;&amp; getAdapter() != null)&#123; setCurrentItem(getAdapter().getCount() - 1 , false); &#125;else&#123; setCurrentItem(0 , false); &#125; &#125;&#125; 设置 adapter 数据反置 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CommonPagerAdapter extends FragmentStatePagerAdapter &#123; private final List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(); private final List&lt;String&gt; mFragmentsTitles = new ArrayList&lt;&gt;(); private boolean mIsRtrl; public CommonPagerAdapter(FragmentManager fm, boolean mIsRtrl) &#123; super(fm); this.mIsRtrl = mIsRtrl; &#125; public void addFragment(Fragment fragment, String title) &#123; mFragments.add(fragment); mFragmentsTitles.add(title); &#125; public void clearFragment() &#123; mFragments.clear(); mFragmentsTitles.clear(); &#125; @Override public Fragment getItem(int position) &#123; if (mIsRtrl &amp;&amp; mFragments.size() &gt; 0) &#123; return mFragments.get(mFragments.size() - position - 1); &#125; else &#123; return mFragments.get(position); &#125; &#125; @Override public int getCount() &#123; return mFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; if (mIsRtrl &amp;&amp; mFragmentsTitles.size() &gt; 0) &#123; return mFragmentsTitles.get(mFragmentsTitles.size() - position - 1); &#125; else &#123; return mFragmentsTitles.get(position); &#125; &#125;&#125; 完整布局代码汉语布局 activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/act_tab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll&quot; app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabIndicatorHeight=&quot;2dp&quot; app:tabMode=&quot;scrollable&quot; app:tabSelectedTextColor=&quot;#666666&quot; app:tabTextColor=&quot;@android:color/darker_gray&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;com.yankang.rtldemo.RTLViewPager android:id=&quot;@+id/act_viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt;&lt;/com.yankang.rtldemo.RTLViewPager&gt; &lt;Button android:id=&quot;@+id/change_lang&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/change_lang&quot; /&gt;&lt;/LinearLayout&gt; 维语布局 activity_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layoutDirection=&quot;rtl&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/act_tab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;48dp&quot; android:layoutDirection=&quot;ltr&quot; app:layout_scrollFlags=&quot;scroll&quot; app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabIndicatorHeight=&quot;2dp&quot; app:tabMode=&quot;scrollable&quot; app:tabSelectedTextColor=&quot;#666666&quot; app:tabTextColor=&quot;@android:color/darker_gray&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;com.yankang.rtldemo.RTLViewPager android:id=&quot;@+id/act_viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt;&lt;/com.yankang.rtldemo.RTLViewPager&gt; &lt;Button android:id=&quot;@+id/change_lang&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/change_lang&quot; /&gt;&lt;/LinearLayout&gt; 文件夹结构（rtl布局我放在 layout_en_rUS 下） 以上源码地址 好吧， 到这里我们基本实现了双语版本 ， 以及版本的切换。但是 ，我们layout 多了一份 ， String.xml多了一份（这个无法避免），一方面需要同时维护两套布局，布局文件很多的情况下很不方便，另一方面也增大了app的大小。 布局优化使用databinding 简化布局App字符串常量类 StringVaule.java 1234567891011121314151617181920212223242526272829package com.yankang.rtldemo.Strings;import android.databinding.BaseObservable;import android.databinding.Bindable;import com.yankang.rtldemo.BR;/** * Created by yankang on 2017/1/8. * app 字符串常量类 */public class StringVaule extends BaseObservable &#123; private boolean langType = false; @Bindable public boolean isLangType() &#123; return langType; &#125; public void setLangType(boolean langType) &#123; this.langType = langType; notifyPropertyChanged(BR.langType); &#125; // 文字 public final String btn = &quot;改变&quot;; public final String _btn = &quot;change&quot;;&#125; activity_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.yankang.rtldemo.Strings.StringVaule&quot; /&gt; &lt;import type=&quot;android.view.View&quot; /&gt; &lt;variable name=&quot;string&quot; type=&quot;StringVaule&quot; /&gt; &lt;/data&gt; &lt;LinearLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layoutDirection=&quot;@&#123;string.langType ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR&#125;&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/act_tab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;48dp&quot; android:layoutDirection=&quot;ltr&quot; app:layout_scrollFlags=&quot;scroll&quot; app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabIndicatorHeight=&quot;2dp&quot; app:tabMode=&quot;scrollable&quot; app:tabSelectedTextColor=&quot;#666666&quot; app:tabTextColor=&quot;@android:color/darker_gray&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;com.yankang.rtldemo.Widgets.RTLViewPager android:id=&quot;@+id/act_viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt;&lt;/com.yankang.rtldemo.Widgets.RTLViewPager&gt; &lt;Button android:id=&quot;@+id/change_lang&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;string.langType ? string._btn : string.btn&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; RecycleView item list_item.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.yankang.rtldemo.Strings.StringVaule&quot; /&gt; &lt;import type=&quot;com.yankang.rtldemo.Model.Student&quot; /&gt; &lt;variable name=&quot;string&quot; type=&quot;StringVaule&quot; /&gt; &lt;variable name=&quot;stu&quot; type=&quot;Student&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;15dp&quot; android:scaleType=&quot;centerCrop&quot; android:scaleX=&quot;@&#123;string.langType ? -1f : 1f&#125;&quot; app:image=&quot;@&#123;stu.imageUrl&#125;&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;stu.name&#125;&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;@&#123;stu.gender&#125;&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginEnd=&quot;10dp&quot; android:scaleX=&quot;@&#123;string.langType ? -1f : 1f&#125;&quot; android:src=&quot;@drawable/ic_keyboard_arrow_right_black_36dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.yankang.rtldemo1;import android.content.Intent;import android.databinding.DataBindingUtil;import android.os.Bundle;import android.support.design.widget.TabLayout;import android.support.v4.app.Fragment;import android.support.v7.app.AppCompatActivity;import com.yankang.rtldemo1.Adapters.CommonPagerAdapter;import com.yankang.rtldemo1.Widgets.RTLViewPager;import com.yankang.rtldemo1.data.PreferManager;import com.yankang.rtldemo1.databinding.ActivityMainBinding;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;import static com.yankang.rtldemo1.App.stringVaule;public class MainActivity extends AppCompatActivity &#123; @Bind(R.id.act_tab) TabLayout actTab; @Bind(R.id.act_viewpager) RTLViewPager actViewpager; private CommonPagerAdapter adapter; private boolean isRtl = false; private ActivityMainBinding binding; private PreferManager preferManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.activity_main); ButterKnife.bind(this); initView(); &#125; private void initView() &#123; preferManager = PreferManager.getInstance(this); binding.setString(App.stringVaule); isRtl = preferManager.getLangType() == Constant.LANG_EN; stringVaule.setLangType(isRtl); adapter = new CommonPagerAdapter(getSupportFragmentManager(), isRtl); for (int i = 0; i &lt; 3; i++) &#123; Fragment fragment = new TestFragment(); adapter.addFragment(fragment, &quot;标签&quot; + i); &#125; actTab.setupWithViewPager(actViewpager); actViewpager.setAdapter(adapter); actViewpager.setRtlOriented(isRtl); &#125; @OnClick(R.id.change_lang) public void change() &#123; if (preferManager.getLangType() == Constant.LANG_EN) &#123; preferManager.setLangType(Constant.LANG_ZH); &#125; else &#123; preferManager.setLangType(Constant.LANG_EN); &#125; startActivity(new Intent(this, MainActivity.class)); finish(); &#125;&#125; RecycleView adapter 配置Databinding CommonAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.yankang.rtldemo.Adapters;import android.databinding.DataBindingUtil;import android.databinding.ViewDataBinding;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.yankang.rtldemo.App;import com.yankang.rtldemo.BR;import com.yankang.rtldemo.Model.Student;import com.yankang.rtldemo.R;import java.util.ArrayList;/** * Created by yankang on 2017/1/8. * MVVM 在recycleview 中的应用 */public class CommonAdapter extends RecyclerView.Adapter&lt;CommonAdapter.ViewHoler&gt; &#123; private final ArrayList&lt;Student&gt; mData = new ArrayList&lt;&gt;(); public CommonAdapter(ArrayList&lt;Student&gt; data) &#123; mData.addAll(data); &#125; @Override public ViewHoler onCreateViewHolder(ViewGroup parent, int viewType) &#123; ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater .from(parent.getContext()), R.layout.list_item, parent, false); ViewHoler holder = new ViewHoler(binding.getRoot()); holder.setViewDataBinding(binding); return holder; &#125; //设置数据 @Override public void onBindViewHolder(ViewHoler holder, int position) &#123; //修改绑定数据 holder.getViewDataBinding().setVariable(BR.stu, mData.get(position)); holder.getViewDataBinding().setVariable(BR.string, App.stringVaule); //刷新 holder.getViewDataBinding().executePendingBindings(); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; class ViewHoler extends RecyclerView.ViewHolder &#123; private ViewDataBinding viewDataBinding; public ViewHoler(View itemView) &#123; super(itemView); &#125; public ViewDataBinding getViewDataBinding() &#123; return viewDataBinding; &#125; public void setViewDataBinding(ViewDataBinding viewDataBinding) &#123; this.viewDataBinding = viewDataBinding; &#125; &#125;&#125; 以上源码地址 实际效果使用DataBinding后，我们不用再维护多套布局 ， 极大的简化了代码。总体来说还是很简单的。 end~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C从忘记到捡起---指针]]></title>
    <url>%2F2017%2F01%2F10%2FC%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针一般指向一个函数或一个变量。在使用一个指针时，一个程序既可以直接使用这个指针所储存的内存地址，又可以使用这个地址里储存的函数的值 ##C语言基础–指针 简单例子 123int v = 10;int *p = &amp;v;printf(&quot;指针值：%d \n&quot; , *p); 空指针 123456int *n = NULL;printf(&quot;空指针： %x \n&quot; , n);//判断是否为空指针if(n)...if(!n) 指针简单运算 123456789101112int attr[5] = &#123;1 , 2 , 3 , 4 , 5&#125;;int *ap;ap = attr;for (int i = 0; i &lt; 5; i ++)&#123; printf(&quot;指针递增运算 %d \n&quot; , *ap); ap ++;&#125;int length = 5;ap = &amp;attr[length - 1];for (int i = length -1 ; i &gt;= 0 ; i --)&#123; printf(&quot;指针递减运算: %d \n&quot; , *ap); ap--; &#125; 指针比较 12345while (ap &lt;= &amp;attr[length - 1])&#123; printf(&quot;指针比较运算：%d \n&quot; , *ap); ap++;&#125; 数组指针 12345678//数组指针int* pointAttr[5];for(int i = 0 ; i &lt; 5 ; i ++)&#123;pointAttr[i] = &amp;attr[i];&#125;for (int i = 0 ; i &lt; 5; i++) &#123;printf(&quot;数组指针：%d \n&quot; , *pointAttr[i]);&#125; 传递指针给函数 123456789101112//给函数 传递指针参数int* pointMethod(int* num1 , int* num2)&#123;if (*num1 &gt; *num2)&#123; return num1;&#125;else&#123; return num2;&#125;&#125;int a = 10;int b = 20; int* max = pointMethod(&amp;a, &amp;b);printf(&quot;最大值：%d \n&quot; , *max); 多级指针 12345int mutilPoints(int* a , int* b)&#123; int** aa = &amp;a; int** bb = &amp;b; return **aa + **bb;&#125; 函数指针 12345678910111213141516// 声明函数指针 变量int* (*myPoint)(int * a , int *b);int main(int argc, const char * argv[]) //使用myPoint = &amp;mp;int a1 = 20;int b1 = 10;int* c = (*myPoint)(&amp;a1, &amp;b1);printf(&quot;函数指针：%d \n&quot; , *c);//函数int* mp(int* a , int* b)&#123; int c = *a - *b; return &amp;c;&#125; 指针函数 123( ( void( )() )0 )()x = (void( )())0 //强转 为指针函数( x )() //调用函数 函数指针数组 12345678910111213141516171819202122int* (*mp)(int* a , int * b)int* (*mp[2](int* a , int * b))//方法int* f1(int *a , int* b)&#123;...&#125;int* f2(int *a , int* b)&#123;...&#125; mp[0] = &amp;f1;mp[1] = &amp;f2; (*mp[0])(&amp;a , &amp;b);(*mp[1])(&amp;a , &amp;b);//函数指针数组的指针char * (*a[3])(char * p);char * (*(*pf)[3])(char * p);pf = &amp;a; a[0] = fun1; //a[1] = &amp;fun2; //效果同上a[2] = &amp;fun3; pf[0][0](&quot;fun1&quot;);pf[0][1](&quot;fun2&quot;);pf[0][2](&quot;fun3&quot;);]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C指针</tag>
      </tags>
  </entry>
</search>
